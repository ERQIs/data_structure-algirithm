# P2700 逐个击破

## 题目背景

三大战役的平津战场上，傅作义集团在以北平、天津为中心，东起唐山西至张家口的铁路线上摆起子一字长蛇阵，并企图在溃败时从海上南逃或向西逃窜。为了就地歼敌不让其逃走，指挥官制定了先切断敌人东西两头退路然后再逐个歼灭敌人的战略方针。秉承伟大军事家的战略思想，作为一个有智慧的军长你，遇到了一个类似的战场局面。

## 题目描述

现在有 $N$ 个城市，其中 $K$ 个被敌方军团占领了，$N$ 个城市间有 $N-1$ 条公路相连，破坏其中某条公路的代价是已知的，现在，告诉你 $K$ 个敌方军团所在的城市，以及所有公路破坏的代价，请你算出花费最少的代价将这 $K$ 个地方军团互相隔离开，以便第二步逐个击破敌人。

## 输入格式

第一行包含两个正整数 $N$ 和 $K$。

第二行包含 $K$ 个整数，表示哪个城市被敌军占领。

接下来 $N-1$ 行，每行包含三个正整数 $a,b,c$，表示从 $a$ 城市到 $b$ 城市有一条公路，以及破坏的代价 $c$。城市的编号从 $0$ 开始。

## 输出格式

输出一行一个整数，表示最少花费的代价。

## 输入输出样例 #1

### 输入 #1

```
5 3
1 2 4
1 0 4
1 3 8
2 1 1
2 4 3
```

### 输出 #1

```
4
```

## 说明/提示

对于 $10\%$ 的数据，$N\le 10$。

对于 $100\%$ 的数据，$2\le N\le10^5$，$2\le K\le N$，$1\le c\le 10^6$。





https://www.luogu.com.cn/article/cch097x2




当然可以！这道题是一个**树上隔离问题**，其实本质是树形结构上的一个**反向最小生成树问题**或称为**最大生成森林问题**。我们一步一步讲清楚它到底在干什么👇

---

## 🧭 题意简化：

- 给定一棵树（N 个点 N-1 条边，说明图是连通无环的）。
- 有 K 个点被敌人占据了。
- 我们的目标是**将这 K 个点互相隔离开**（即敌军城市两两之间不连通）。
- 我们可以通过**破坏某些边**，代价为 `c`。
- **要求：最小破坏代价**，使敌军城市都不在同一个连通块里（彼此完全隔离）。

---

## 🧠 思路分析：

### ✅ 性质一：这是一棵树
- 所以任意两个点之间路径是唯一的。
- 如果要让 K 个敌军城市**彼此不连通**，我们必须把它们分开成 K 个互相不连通的子树。

### ✅ 性质二：破坏 K-1 条边就够了
- 一棵树中 K 个点想分成 K 个子树，最少要断开 K-1 条边。
- 否则至少会有两个敌军城市还连着。

> 💡 所以我们需要选出若干条边，把敌军城市完全隔离 —— 至少断掉 K-1 条边。

---

## 🎯 目标变成什么？

我们要在树中选择 K-1 条边，使它们的**破坏代价之和最小**，并且能让所有敌人城市完全不连通。

---

## ✨ 核心思想（反向 Kruskal）：

我们反过来想：  
- 如果我们将所有边都保留，不断地连通城市，最终所有点连成一棵树。
- 如果我们从**所有边中只选 N-1-(K-1) = N-K 条边**，那剩下的 K-1 条边就被“破坏”了 —— 正是我们要的效果。

所以：
- 如果我们对边权从大到小排序，然后只保留其中的 N-K 条边，剩下的边就是我们要“断掉”的那 K-1 条。
- 于是我们只需要让这 K-1 条被“破坏”的边尽量代价**最小**，总破坏代价最小！

---

## ✅ 具体做法（推荐解法：**并查集 + Kruskal**）：

1. **用并查集维护连通块**。
2. 将所有边按代价从大到小排序（因为我们想尽量保留大边）。
3. 只合并那些两个点**不是敌军城市或两个都没敌人**的边。
4. 每个连通块维护一个标志：是否包含敌军。
5. 如果两个点在不同集合：
   - 若两个集合**都没有敌军城市**：正常合并。
   - 若一个有敌军、一个没有敌军：正常合并。
   - 若两个集合**都有敌军城市**：**不能合并**（否则敌军会连起来！），**我们就得“破坏”这条边**。

---

## 🔨 简单代码框架（核心逻辑）：

```cpp
struct Edge {
    int u, v, w;
    bool operator<(const Edge &e) const {
        return w > e.w; // 从大到小排
    }
};

int fa[MAXN];
bool hasEnemy[MAXN]; // 是否包含敌人

int find(int x) {
    return x == fa[x] ? x : fa[x] = find(fa[x]);
}

bool merge(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx == fy) return false;

    if (hasEnemy[fx] && hasEnemy[fy]) return false; // 敌军不能合并
    fa[fy] = fx;
    hasEnemy[fx] |= hasEnemy[fy]; // 合并敌军标记
    return true;
}
```

然后主程序中遍历边（从大到小），只在可以合并时合并，不能合并的边代价加入答案中，最后破坏代价总和就是我们要的答案。

---

## 📌 总结步骤：

1. 把所有边按代价从大到小排序。
2. 使用并查集维护连通性，额外维护每个集合是否有敌军城市。
3. 遍历边：
   - 如果两个点在不同集合，且不都是敌人集合，合并。
   - 否则，不能合并，**加进总代价中**。
4. 最后破坏了 K-1 条边，总代价就是答案。
