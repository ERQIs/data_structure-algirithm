# 计数排序
计数排序的原理还是蛮简单的，这种排序适用于知道确切的数字范围（且范围较小）的整数之间的排序。（或者元素的范围被限制在较小的可数范围内的排序问题应该都可以吧）。正是这种限制条件使得这种排序方式可以摆脱两两比较的排序方式来以空间复杂度换取时间复杂度（复杂度是$O(n)$的）。还有一点很重要的是这种排序是稳定的。也就是说相同的元素在排好序后原本的先后顺序不会改变，这是一条奇妙的性质，在基数排序中会看到对这种性质加以利用的例子。
原理简单的来说就是首先统计每个元素的数量，再根据这个统计信息**直接把元素放到它应该在的位置上**。
## 实现
具体的实现在 *"Introduction to Algorithm"* 上有过介绍，其实PP（蒲鹏）的PPT上也有相关的介绍.
```c
int* counting_sort(int* nums, int n)
//计数排序，假定数据范围已经知道就是0~1000之间
{
    int* tmp = (int*) malloc (sizeof(int) * 1001);
    //tmp数组用于统计每个范围内可能的数组出现过的次数，这也是用空间来换取时间的最重要的开销部分。

    int* ret = (int*) malloc (sizeof(int) * n);
    memset(tmp, 0, sizeof(int) * 1001);

    for (int i = 0; i < n; i ++){
        tmp[ nums[i] ] ++;
    }

    for (int i = 1; i < 1001; i ++){
        tmp[i] += tmp[i - 1];
    }
    //从前往后做一次前缀和，这样的话每个index_i上的数字表明数组里小于等于i的数字的个数。

    for (int i = n - 1; i >= 0; i --){
        int now = nums[i];
        ret[-- tmp[now]] = now;
    }
    /*
    从后往前填充返回数组，这里的填充顺序（从后往前依次从原数组中取出数字e，然后从tmp中查询小于等于e的元素的个数，
    然后把e放到相应的位置上并且把tmp上的数量减一）。这种操作方式也是计数排序成为一个稳定排序的原因。
    想想看，如果是以从前往后的顺序来从原数组中取出e的话，相等的元素在返回数组中的顺序就是原来顺序的逆序了。
    这种稳定性在排序带有卫星数据（也就是伴随的数据）的元素组成的序列时会显得很重要（如果卫星数据的顺序很重要的话）。
    */
    free(nums);
    free(tmp);
    return ret;
}
```

###### 最后修改日期 2023/4/22