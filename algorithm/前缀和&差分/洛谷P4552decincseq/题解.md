# 思路
这道题让我第一次领略到了差分的奇妙。

这道题的要求:对给定数组做k次区间操作（区间整体+1 或者 区间整体-1， 不限定每次区间的选取），使得最后原数组中所有的数字都相同。求k的最小值。 k次操作后可以得到的不同满足条件的序列的数量。 

在没有很好地理解差分操作的时候我乍一看，哇，什么啊，~~爆率真的很高啊~~ 不懂啊。怎么做，硬做？把图画出来，每次对横切面+1，-1，这也不是个办法啊....  
然后 ~~明智的我直接打开了评论区~~ 在好好了解过差分之后，对这道题有了新的理解。  

为什么是差分？因为在差分数组中对操作原数组做区间操作简直不要太简单，这不就是我们想做的吗？最开始我也想到了差分，但没想到差分的应用如此的....普适？就像....数学定理一样。  

>1.在原数组中的区间操作 ***等价于*** 在差分数组中的加减操作  
>2.原数组的所有元素相同 ***等价于*** 差分数组除了第一项和逻辑上的最后一项（记得差分数组需要开到有效位+1的位置上吗）都是0  
>3.k次操作后能得到的合法的数组数量 ***等于*** k次操作后合法差分数组的第一项能取到的数字的数量。  

所以问题就变成：在差分数组中进行操作（每次在一个位置上 +1，一个位置上 -1。这样算一次操作。可以操作的位置从1开始直到逻辑上的最后一项），最少几次后可以让差分数组变成 除了第一和最后一项之外都是0的数组？这k次操作后第一个元素能取多少种数字？  

一下子简单了好多:我们令差分数组中 需要置为0的区域 中 所有正数的和 为 ${sum_{positive}}$, 所有负数的绝对值之和 为 ${sum_{negetive}}$, 不难发现需要的最小操作次数 $k={max(sum_{positive}, sum_{negetive})}$, 而第一个位置能取到的数字的数量为 ${1+|sum_{positive}-sum_{negetive|}}$ (因为在贪心地做完 ${min(sum_{positive}, sum_{negetive})}$ 次操作（每次都从置0区域中的正数中-1,置0区域中的负数上+1）之后置0区域还需要 ${|sum_{positive}-sum_{negetive}|}$ 次 +1 或者这么多次 -1 操作， 但是总得有对应的 -1 或者 +1 操作，这两个就只能做到第一个或者最后一个位置上了，所以第1个数字还可以只向上或者只向下取 ${|sum_{positive}-sum_{negetive}|}$ 个数字，合起来就是前面的答案)。

# AC代码
因为做这道题是在总结差分之前，所以约定的差分数组可能不是像上面讨论的这样。  
```c
# include <stdio.h>
# include <stdlib.h>

int main()
{
    int n;
    scanf("%d", &n);
    int *nums = malloc (sizeof(int) * n);
    for (int i = 0; i < n; i ++){
        scanf("%d", nums + i);
    }
    for (int i = n - 1; i >= 1; i --){
        nums[i] -= nums[i - 1];
    }
    long long pos = 0, neg = 0;
    for (int i = 1; i < n; i ++){
        if (nums[i] > 0){
            pos += nums[i];
        } else if (nums[i] < 0){
            neg += -nums[i];
        }
    }
    printf("%lld\n%lld\n", pos > neg ? pos : neg, 1 + (pos > neg ? pos - neg : neg - pos));
    return 0;
```

###### 最后修改日期 2023/4/22