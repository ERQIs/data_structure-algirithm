# 前缀和 & 差分

前缀和和差分这两个东西是一对逆运算的过程，虽然说这两个操作类似于离散数据上的微分和积分操作，但是算法题似乎把这种思想玩出了一种新的奇妙的境界。  
这两对东西在葛总算法题里总是跟区间上的修改和查询操作有关，对原序列做前缀和后可以很方便地做查询区间和操作、做差分后可以很方便地做 对一段区间中的每个数字都+$k$($k$属于实数，当然这个方法具有可拓展性)的操作。  
如果有一些跟微分理论和积分理论相关的类似思想的话，记得来扩展这里!

## 构建前缀和数组&差分数组

### 前缀和
```c
// 构建前缀和数组

int nums[n + 1]; //这是原始序列，构建的时候方便起见 从1开始存放n个数字

int prefix[n + 1];
prefix[0] = 0;   //注意前缀和数组位置0上的数字是0，这是为了查询左边为1的区间
for (int i = 1; i <= n; i ++){
    prefix[i] = prefix[i - 1] + nums[i];
}


//查询前缀和数组

//这里查询 nums[i, i+1, i+2, ... , j-2, j-1, j] (左闭右闭) 中所有元素的和
int sum_ij = prefix[j] - prefix[i - 1];
```

### 差分
```c
// 构建差分数组

int nums[n + 1]; //原始序列，跟上面一样是从1开始存的
//由于对于差分数组来说原数组就相当于前缀和数组，所以这里我们约定 nums[0] = 0, 以方便计算

int diff[n + 2]; //对右端为最后一个元素的区间做操作的时候会涉及到第n个有效位置的下一个位置
//这样约定的差分数组中 diff[n + 1] 项在形式上有用，但 diff[0] 貌似是彻底没用的。
for (int i = 1; i <= n; i ++){
    diff[i] = nums[i] - nums[i - 1];
}


//通过差分数组对原数组做区间操作：

//这里对左闭右闭区间 nums[i, i+1, i+2, ... , j-2, j-1, j] (左闭右闭) 中所有的元素都做一次 + k操作
diff[i] += k;
diff[j + 1] -= k;

//只要再对差分数组做一次前缀和操作就可以得到操作之后的数组
```

##### 体会
差分有一个奇妙的地方在于在做完差分操作之后，整个的区间+，区间- 操作都变成了对元素的加减操作(从n次操作变成了2次操作), 在差分数组上处理区间问题就好像....来到了另一个有着一套单独的计算规则的空间了一样:整个的问题目标会发生变化，操作方式会发生变化————都变得更简单了。这么说可能还是不太明确,打个比方就好像是 ***对数*** 的发明把指数函数上的操作变成线性函数的操作，把乘法变成了加法一样....

###### 最后修改日期 2023/4/22